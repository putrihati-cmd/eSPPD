Berikut Full Architecture Microservices E-SPPD dengan Python Document Service:
Markdown
Copy
Code
Preview
# E-SPPD MICROSERVICES ARCHITECTURE
## Full Workflow A-Z with Python Document Engine

### SYSTEM OVERVIEW

┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   API Gateway   │────▶│  Auth Service    │────▶│   PostgreSQL    │
│   (Nginx/Kong)  │     │   (Laravel)      │     │   (Auth DB)     │
└────────┬────────┘     └──────────────────┘     └─────────────────┘
         │
         ├──────────────▶┌──────────────────┐
         │               │  Core SPPD       │
         │               │  (Laravel)       │
         │               └────────┬─────────┘
         │                        │
         ├──────────────▶┌──────────────────┐     ┌─────────────────┐
         │               │  Document        │────▶│   Python PDF    │
         │               │  Orchestrator    │     │   Service       │
         │               │   (Laravel)      │     │  (FastAPI/      │
         │               └──────────────────┘     │   Celery)       │
         │                                         └─────────────────┘
         │
         └──────────────▶┌──────────────────┐
                         │  Notification    │
                         │  Service         │
                         └──────────────────┘

---

## 1. SERVICE DEFINITIONS

### Service A: API Gateway (Kong/Nginx)
**Tech:** Kong Gateway / Nginx + Lua  
**Port:** 80/443  
**Function:** Routing, Rate Limiting, JWT Validation

```yaml
# kong.yml
services:
  - name: auth-service
    url: http://auth-service:8081
    routes:
      - name: auth-routes
        paths: ["/api/auth"]
    
  - name: core-sppd
    url: http://core-sppd:8082
    routes:
      - name: sppd-routes
        paths: ["/api/sppd", "/api/approval"]
        plugins:
          - name: jwt
            config:
              key_claim_name: iss
              secret_is_base64: false

  - name: document-service
    url: http://document-service:8083
    routes:
      - name: document-routes  
        paths: ["/api/documents", "/api/generate"]
Service B: Auth Service (Laravel)
Database: PostgreSQL (auth_db)
Responsibility: Authentication, Authorization, Hierarchy Data
php
Copy
// Key Logic: NIP-to-Token conversion
public function login(LoginRequest $request) {
    $employee = Employee::where('nip', $request->nip)->first();
    
    // Generate JWT dengan claims hierarchy
    $token = JWT::encode([
        'sub' => $employee->nip,
        'level' => $employee->approval_level,
        'faculty' => $employee->faculty,
        'iss' => 'esppd-auth',
        'iat' => time(),
        'exp' => time() + 3600
    ], $privateKey, 'RS256');
    
    return ['token' => $token, 'level' => $employee->approval_level];
}
Service C: Core SPPD (Laravel)
Database: PostgreSQL (sppd_db)
Queue: Redis (for async jobs)
Responsibility: Business Logic, Approval Workflow, State Management
Key Entity:
php
Copy
// SPPD Aggregate Root
class Sppd extends Model {
    protected $connection = 'sppd_db';
    
    // State Machine Pattern
    public function transitionTo(string $newState, string $actorNip) {
        $allowed = match($this->status) {
            'draft' => ['pending'],
            'pending' => ['approved', 'rejected'],
            'rejected' => ['draft'],
            default => []
        };
        
        if (!in_array($newState, $allowed)) {
            throw new InvalidStateTransition();
        }
        
        $this->status = $newState;
        $this->save();
        
        // Emit Event to Message Bus
        event(new SppdStateChanged($this->id, $newState, $actorNip));
    }
}
Service D: Document Service (Python/FastAPI)
Tech Stack: FastAPI, Celery, Redis, WeasyPrint/Jinja2
Port: 8083
Responsibility: PDF Generation, Document Templates, OCR, Archive
Why Python?
Better PDF libraries (WeasyPrint, ReportLab) than PHP
Native async support for high-concurrency generation
Easy integration with ML (future: OCR, anomaly detection)
Superior text processing for complex layouts
Python
Copy
# main.py (FastAPI Document Service)
from fastapi import FastAPI, BackgroundTasks, HTTPException
from celery import Celery
from jinja2 import Environment, FileSystemLoader
from weasyprint import HTML, CSS
import aiofiles
import aioboto3
import json

app = FastAPI(title="E-SPPD Document Service")
celery_app = Celery('document_tasks', broker='redis://redis:6379/0')

# Template Engine
env = Environment(loader=FileSystemLoader('/app/templates'))

@app.post("/generate/{doc_type}")
async def queue_document_generation(
    doc_type: str,  # 'spt', 'spd', 'laporan'
    data: dict,
    background_tasks: BackgroundTasks
):
    """
    Logic: Async document generation via Celery
    - Accept JSON data from Core Service
    - Queue to Celery worker (prevent timeout)
    - Return job_id immediately (polling pattern)
    """
    job = generate_document.delay(doc_type, data)
    return {"job_id": job.id, "status": "queued"}

@celery_app.task(bind=True)
def generate_document(self, doc_type: str, data: dict):
    """
    Worker Logic:
    1. Load template (Jinja2)
    2. Render HTML dengan data
    3. Convert to PDF (WeasyPrint)
    4. Upload to S3/MinIO
    5. Notify Core Service via webhook
    """
    try:
        # Update progress
        self.update_state(state='PROGRESS', meta={'step': 'loading_template'})
        template = env.get_template(f"{doc_type}.html")
        
        # Logic: Format currency, terbilang, tanggal Indonesia
        formatted_data = format_indonesian_data(data)
        html_out = template.render(**formatted_data)
        
        # Progress
        self.update_state(state='PROGRESS', meta={'step': 'rendering_pdf'})
        
        # Generate PDF dengan CSS kemendikbud
        css = CSS(filename=f'/app/assets/{doc_type}.css')
        pdf = HTML(string=html_out).write_pdf(stylesheets=[css])
        
        # Upload (async simulation)
        file_path = f"/tmp/{data['sppd_id']}_{doc_type}.pdf"
        with open(file_path, 'wb') as f:
            f.write(pdf)
        
        # Upload ke Object Storage
        s3_key = f"documents/{data['tahun']}/{data['unit']}/{data['sppd_id']}_{doc_type}.pdf"
        upload_to_s3(file_path, s3_key)
        
        # Webhook ke Core Service
        notify_core_service(data['sppd_id'], doc_type, s3_key, 'completed')
        
        return {"status": "completed", "s3_key": s3_key}
        
    except Exception as exc:
        self.update_state(state='FAILURE', meta={'error': str(exc)})
        raise exc

def format_indonesian_data(data: dict) -> dict:
    """
    Business Logic: Format data untuk Indonesia
    - Rupiah format: Rp 1.000.000
    - Terbilang: "Satu Juta Rupiah"
    - Tanggal: "Senin, 15 Januari 2025"
    """
    from num2words import num2words
    
    total = data.get('total_biaya', 0)
    data['total_formatted'] = f"Rp {total:,.0f}".replace(",", ".")
    data['terbilang'] = num2words(total, lang='id') + " Rupiah"
    
    # Format tanggal Indonesia
    import locale
    locale.setlocale(locale.LC_TIME, 'id_ID')
    # ... date formatting logic
    
    return data
2. FULL WORKFLOW A-Z WITH DATA FLOW
A. LOGIN & TOKEN GENERATION
Flow:
User (Browser) → POST /api/auth/login {nip, password}
Gateway → Auth Service
Auth Service Logic:
Copy
Validate NIP exists in Employee DB
↓
Check password (bcrypt)
↓
Generate JWT with claims:
  - sub: NIP
  - level: 1-6  
  - faculty: FTIK/FEBI
  - exp: 1 hour
↓
Return {access_token, refresh_token, level}
Sequence Diagram:
Mermaid
Fullscreen 
Download 
Copy
Code
Preview
Redis (Token Blacklist)
Auth Service
API Gateway
User
Redis (Token Blacklist)
Auth Service
API Gateway
User
POST /login {nip, pass}
Forward
Verify NIP + Password
Store refresh token
{jwt_token, level}
200 OK + Set-Cookie
B. SPPD SUBMISSION (Async with Saga Pattern)
Complexity: Heavy operation (file upload, validation, initial PDF draft)
Flow:
Client POST /api/sppd/submit dengan attachment
Core SPPD:
Save to DB (status: draft)
Upload attachment to Object Storage
Async Call ke Document Service untuk generate draft PDF (optional)
Queue Job: ValidateAnggaranJob
State: draft → pending
Event Emit: SppdSubmittedEvent → Redis Pub/Sub
Logic Detail:
php
Copy
// Core Service Controller
public function store(Request $request) {
    // Logic: Check concurrent SPPD (tidak boleh overlap tanggal)
    $hasOverlap = Sppd::where('employee_nip', $request->user()->nip)
        ->whereNotIn('status', ['rejected', 'expired'])
        ->where(function($q) use ($request) {
            $q->whereBetween('start_date', [$request->start, $request->end])
              ->orWhereBetween('end_date', [$request->start, $request->end]);
        })->exists();
        
    if ($hasOverlap) {
        return response()->json(['error' => 'Tanggal tabrakan dengan SPPD aktif'], 422);
    }
    
    // Save SPPD
    $sppd = Sppd::create([...$request->all(), 'status' => 'draft']);
    
    // Upload attachment async
    dispatch(new UploadAttachmentJob($sppd, $request->file('attachment')));
    
    // Trigger Python Document Service untuk preview (async)
    Http::async()->post('http://document-service:8083/generate/preview', [
        'sppd_id' => $sppd->id,
        'data' => $sppd->toArray()
    ]);
    
    return response()->json(['sppd_id' => $sppd->id, 'status' => 'draft']);
}
C. APPROVAL WORKFLOW (Event-Driven)
Architecture Pattern: Event Sourcing + CQRS (Command Query Responsibility Separation)
State Transitions:
Copy
draft → pending → approved_level_2 → approved_level_3 → ... → approved_final
   ↓       ↓           ↓
rejected (bisa revert ke draft)
Microservices Communication:
php
Copy
// When approval button clicked
public function approve($sppdId) {
    $sppd = Sppd::find($sppdId);
    
    // Logic: Check level authorization dari JWT
    $userLevel = auth()->user()->approval_level;
    $neededLevel = $this->calculateNeededLevel($sppd);
    
    if ($userLevel < $neededLevel) {
        abort(403);
    }
    
    // Logic: Check budget via Budget Service (gRPC/HTTP)
    $budgetCheck = Http::post('http://budget-service:8084/check', [
        'anggaran_id' => $sppd->anggaran_id,
        'amount' => $sppd->total_biaya
    ]);
    
    if (!$budgetCheck->json('sufficient')) {
        return ['error' => 'Anggaran tidak mencukupi'];
    }
    
    // State Machine
    DB::transaction(function() use ($sppd, $userLevel) {
        $sppd->transitionTo('approved_level_' . $userLevel);
        
        // Record domain event
        EventStore::create([
            'aggregate_id' => $sppd->id,
            'type' => 'SppdApproved',
            'payload' => json_encode([
                'approver_nip' => auth()->user()->nip,
                'level' => $userLevel,
                'timestamp' => now()
            ])
        ]);
        
        // Determine next or finalize
        if ($userLevel >= 6) { // Rektor final
            $this->finalizeSppd($sppd);
        } else {
            // Forward to next via Event
            event(new ForwardApprovalEvent($sppd, $userLevel + 1));
        }
    });
    
    return ['status' => 'approved'];
}

private function finalizeSppd($sppd) {
    // Generate nomor surat (idempotent)
    $nomor = $this->generateNomorSurat($sppd);
    $sppd->update(['sppd_number' => $nomor, 'status' => 'approved']);
    
    // Commit budget (Budget Service)
    Http::post('http://budget-service:8084/commit', [
        'anggaran_id' => $sppd->anggaran_id,
        'amount' => $sppd->total_biaya,
        'sppd_id' => $sppd->id
    ]);
    
    // Trigger Python Document Service untuk final SPT & SPD
    Http::post('http://document-service:8083/generate/spt', [
        'sppd_id' => $sppd->id,
        'final' => true,
        'callback_url' => 'http://core-sppd:8082/webhook/document-ready'
    ]);
    
    Http::post('http://document-service:8083/generate/spd', [
        'sppd_id' => $sppd->id,
        'final' => true
    ]);
}
D. DOCUMENT GENERATION (Python Service Deep Dive)
Template Engine Logic (Jinja2):
HTML
Preview
Copy
<!-- templates/spd.html (Python Jinja2) -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SPD {{ data.nomor_surat }}</title>
    <style>
        @page { size: A4 landscape; margin: 2cm; }
        .kop { text-align: center; border-bottom: 3px double #000; padding-bottom: 10px; }
        table.rincian { width: 100%; border-collapse: collapse; }
        table.rincian th, table.rincian td { border: 1px solid #000; padding: 8px; }
    </style>
</head>
<body>
    <div class="kop">
        <h3>KEMENTERIAN AGAMA</h3>
        <h2>UIN SAIZU PURWOKERTO</h2>
    </div>
    
    <h3 style="text-align: center;">SURAT PERJALANAN DINAS (SPD)</h3>
    <p>Nomor: {{ data.nomor_surat }}</p>
    
    <table class="identitas">
        <tr><td width="30%">Nama</td><td>: {{ data.pegawai_nama }}</td></tr>
        <tr><td>NIP</td><td>: {{ data.pegawai_nip }}</td></tr>
        <tr><td>Jabatan</td><td>: {{ data.jabatan }}</td></tr>
    </table>
    
    <h4>Rincian Biaya:</h4>
    <table class="rincian">
        <tr>
            <th>No</th>
            <th>Uraian</th>
            <th>Volume</th>
            <th>Satuan</th>
            <th>Harga</th>
            <th>Jumlah</th>
        </tr>
        <tr>
            <td>1</td>
            <td>Transport</td>
            <td>1</td>
            <td>Orang</td>
            <td align="right">{{ data.biaya_transport_formatted }}</td>
            <td align="right">{{ data.biaya_transport_formatted }}</td>
        </tr>
        <!-- Logic: Loop for dynamic items -->
        <tr style="background: #ffffcc;">
            <td colspan="5" align="center"><strong>TOTAL</strong></td>
            <td align="right"><strong>{{ data.total_formatted }}</strong></td>
        </tr>
    </table>
    
    <p>Terbilang: <em>{{ data.terbilang }}</em></p>
    
    <!-- Logic: QR Code untuk verifikasi -->
    <div style="margin-top: 20px; text-align: center;">
        {% if data.qr_code %}
        <img src="data:image/png;base64,{{ data.qr_code }}" width="80">
        <p style="font-size: 8pt;">Scan untuk verifikasi</p>
        {% endif %}
    </div>
</body>
</html>
Celery Worker Configuration:
Python
Copy
# celery_config.py
from celery import Celery

app = Celery('document_service')
app.config_from_object({
    'broker_url': 'redis://redis:6379/0',
    'result_backend': 'redis://redis:6379/0',
    'task_serializer': 'json',
    'accept_content': ['json'],
    'result_serializer': 'json',
    'task_routes': {
        'generate_document': {'queue': 'pdf_generation'},
        'generate_preview': {'queue': 'preview'},
    },
    'task_annotations': {
        'generate_document': {'time_limit': 300.0, 'soft_time_limit': 240.0}
    }
})

# Logic: Retry mechanism untuk PDF yang gagal
@app.task(bind=True, max_retries=3, default_retry_delay=10)
def generate_document_with_retry(self, doc_type, data):
    try:
        return generate_document(doc_type, data)
    except Exception as exc:
        # Retry logic: kalau failed, coba lagi 3x
        raise self.retry(exc=exc)
E. NOTIFICATION SERVICE (Go/Node.js - Optional)
Why Separate Service?
High volume (banyak user)
External dependencies (WhatsApp API, Email SMTP lambat)
Tidak block approval process
Flow:
Copy
Event: SppdSubmitted
  ↓
Redis Pub/Sub / RabbitMQ
  ↓
Notification Service (Consumer)
  ↓
Parallel Send: Email (SMTP) + WhatsApp (API) + Push (Firebase)
3. DATABASE PER SERVICE STRATEGY
Auth DB (PostgreSQL)
employees
users
delegations
Core DB (PostgreSQL)
sppds
sppd_approvals (event store)
anggarans
activity_logs
Document Metadata DB (MongoDB - Optional)
document_jobs
generated_files (S3 keys, checksums)
4. DEPLOYMENT (Docker Compose)
yaml
Copy
# docker-compose.yml
version: '3.8'

services:
  gateway:
    image: kong:3.0
    ports:
      - "80:8000"
      - "443:8443"
    environment:
      - KONG_DATABASE=off
      - KONG_DECLARATIVE_CONFIG=/kong/declarative/kong.yml

  auth-service:
    build: ./services/auth
    environment:
      - DB_HOST=postgres-auth
      - REDIS_HOST=redis
    depends_on:
      - postgres-auth
      - redis

  core-sppd:
    build: ./services/core
    environment:
      - DB_HOST=postgres-core
      - DOCUMENT_SERVICE_URL=http://document-service:8083
    depends_on:
      - postgres-core
      - redis

  document-service:
    build: ./services/document  # Python FastAPI
    environment:
      - CELERY_BROKER_URL=redis://redis:6379/0
      - AWS_S3_BUCKET=esppd-documents
    volumes:
      - ./templates:/app/templates
    depends_on:
      - redis
      - celery-worker

  celery-worker:
    build: ./services/document
    command: celery -A main.celery_app worker --loglevel=info --concurrency=4
    deploy:
      resources:
        limits:
          memory: 2G  # PDF generation memory intensive
    depends_on:
      - redis

  postgres-auth:
    image: postgres:14
    volumes:
      - pg_auth_data:/var/lib/postgresql/data

  postgres-core:
    image: postgres:14
    volumes:
      - pg_core_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  pg_auth_data:
  pg_core_data:
  redis_data:
5. LOGIC SUMMARY (Key Business Rules)
Table
Copy
Step	Logic	Implementation
Login	NIP → Find Employee → Get Email → JWT dengan level	Auth Service
Hierarchy	Level N bisa approve ≤ limit(N), forward ke N+1	Core Saga Pattern
Budget	Check pagu - realisasi ≥ biaya_sppd via gRPC	Budget Service
Double Spend	SELECT FOR UPDATE pada row anggaran	DB Transaction
Auto-Number	COUNT(*) WHERE tahun=2025 + 1, format Kemendikbud	Core Finalize
PDF	Jinja2 → WeasyPrint → S3 → Webhook	Python Service
State	Draft→Pending→Approved_L2→...→Approved_Final	Event Sourcing
Keunggulan Microservices:
Scale Independently: Python PDF service bisa scale 10 replica saat banyak generate laporan akhir tahun
Tech Diversity: PHP untuk business logic, Python untuk document, Go untuk gateway
Failure Isolation: Kalau PDF service down, approval masih bisa jalan (queuing)
Independent Deploy: Update template PDF tanpa restart Laravel
Trade-off: Network latency antara services (gunakan gRPC untuk internal), complexity debugging (gunakan distributed tracing dengan Jaeger/Zipkin).
Status: Architecture siap untuk 1000+ concurrent users dan 10.000+ SPPD per tahun.